import {
  ASTField,
  ASTFunction,
  ASTService,
  ASTServiceField,
  ASTStruct,
  ASTTopLevel,
  ASTType,
} from '../parser/ast';

import creator from 'ts-creator';
// maps between Sophon types and TypeScript types

class TypeScriptGenerator {
  constructor(private ast: ASTTopLevel[]) {
    ast.forEach((x) => this.typeSet.add(x.name));
  }

  typeSet = new Set<string>();

  toType(type: ASTType): string {
    if (typeof type === 'string') {
      if (type in typeMap) {
        return typeMap[type];
      }
      if (!this.typeSet.has(type)) {
        throw new Error(`Type "${type}" is not defined`);
      }
      return type;
    }

    switch (type.name) {
      case '[]':
        return `${this.toType(type.args[0])}[]`;
      case '?':
        return `${this.toType(type.args[0])} | null`;
      default:
        return `${type.name}<${type.args
          .map((x) => this.toType(x))
          .join(', ')}>`;
    }
  }
  genStruct(struct: ASTStruct): string {
    return `export interface ${struct.name} {
${struct.fields.map((f) => `  ${this.genField(f)};`).join('\n')}
}`;
  }

  genStructs() {
    return this.ast
      .filter((x): x is ASTStruct => x instanceof ASTStruct)
      .map((x) => this.genStruct(x))
      .join('\n\n');
  }

  genField(field: ASTField): string {
    return `${field.name}: ${this.toType(field.type)}`;
  }
}

const typeMap: Record<string, string> = {
  string: 'string',
  int: 'number',
  double: 'number',
  boolean: 'boolean',
  void: 'void',
  SophonInstance: 'SophonInstance',
};

export function typescriptSocketIOServer(tree: ASTTopLevel[]): string {
  const tg = new TypeScriptGenerator(tree);

  const services = tree.filter((x): x is ASTService => x instanceof ASTService);
  // generate abstract classes
  const l = services.map((svc) => {
    const allMethods = svc.methods.filter(
      (x): x is ASTServiceField<ASTFunction> => x.type instanceof ASTFunction,
    );
    const methods = allMethods.filter((x) => !x.type.reversed);
    const reversedMethods = allMethods.filter((x) => x.type.reversed);

    return `export class ${svc.name}ServiceSender {
  constructor(private sender: SenderCore, private room: string) {}
  ${reversedMethods.map(
    (fn) => `${fn.name}(${fn.type.input.map((f) => tg.genField(f))}) {
    this.sender.emit(this.room, '${svc.name}/${fn.name}', ${fn.type.input
      .map((f) => f.name)
      .join(', ')});
  }`,
  )}
}

export abstract class Abstract${svc.name}Service {
  readonly NAMESPACE = '${svc.name}';
  static readonly SENDER = ${svc.name}ServiceSender;

  readonly $: (room: string) => ${svc.name}ServiceSender;

${methods
  .map((m) => {
    // the methods

    const inputs = [...m.type.input, new ASTField('ctx', 'SophonInstance')];
    return `  abstract ${m.name}(${inputs
      .map((field) => tg.genField(field))
      .join(', ')}): Promise<${tg.toType(m.type.output)}>;`;
  })
  .filter((x) => x !== '')
  .join('\n')}
}`;
  });

  return `// Generated by Sophon Schema. Do not edit manually!
import { SophonInstance, SenderCore } from '@sophonjs/server';


${tg.genStructs()}

// Services

${l.join('\n\n')}
`;
}

function lowerFirstCharacter(str: string) {
  return str[0].toLowerCase() + str.slice(1);
}

export function typescriptSocketIOClient(tree: ASTTopLevel[]): string {
  const tg = new TypeScriptGenerator(tree);
  const services = tree.filter((x): x is ASTService => x instanceof ASTService);

  return `// Generated by Sophon Schema. Do not edit manually!
import io, { Socket } from 'socket.io-client';


${tg.genStructs()}

class SocketClient {
  constructor(public socket: Socket) {}

  call(event: string, ...args: any[]): any {
    return new Promise((resolve) => {
      this.socket.emit(event, ...args, resolve);
    });
  }

  subscribe(ev: string, handler: any) {
    this.socket.on(ev, handler);
    return () => { this.socket.off(ev, handler); };
  }
}

${services.map((svc) => {
  const allMethods = svc.methods.filter(
    (x): x is ASTServiceField<ASTFunction> => x.type instanceof ASTFunction,
  );
  const methods = allMethods.filter((x) => !x.type.reversed);
  const reversedMethods = allMethods.filter((x) => x.type.reversed);

  return `class ${svc.name}Client {
  constructor(private socket: SocketClient) {}
${methods
    .map((m) => {
      return `  ${m.name}(${m.type.input
        .map((x) => tg.genField(x))
        .join(', ')}): Promise<${tg.toType(m.type.output)}> {
    return this.socket.call('${svc.name}/${m.name}', ${m.type.input
        .map((x) => x.name)
        .join(', ')});
  }`;
    })
    .join('\n')}

${reversedMethods.map((x) => {
        return `  ${x.name}(handler: (${
      x.type.input.map((x) => tg.genField(x)).join(', ') || 'void'
    }) => void) {
    return this.socket.subscribe('${svc.name}/${x.name}', handler);
  }`;
      })}
}`;
})}

export function createClient(url: string) {
  return new Promise<{
${services
  .map((x) => `    ${lowerFirstCharacter(x.name)}: ${x.name}Client;`)
  .join('\n')}
  }>((resolve) => {
    const socket = io(url);

    socket.once('connect', () => {
      const socketClient = new SocketClient(socket);
      resolve({
${services
  .map(
    (x) =>
      `        ${lowerFirstCharacter(x.name)}: new ${
        x.name
      }Client(socketClient),`,
  )
  .join('\n')}
      });
    });
  });
}
`;
}
